import{C as l,A as m,e as $,h as d,T as h}from"./errorBoundary-i6H9MPxW.js";const f=()=>{const e={Accept:"application/vnd.github+json","X-GitHub-Api-Version":m},t=localStorage.getItem("gh-token");return t&&(e.Authorization=`Bearer ${t}`),e},R=e=>new Promise(t=>setTimeout(t,e)),c=new Map,w=e=>{const t=c.get(e);return t?Date.now()-t.timestamp>l?(c.delete(e),null):(console.log(`[Cache] HIT: ${e.substring(0,60)}...`),t.data):null},y=(e,t)=>{if(c.set(e,{data:t,timestamp:Date.now()}),c.size>$){const r=c.keys().next().value;c.delete(r)}},o=async(e,t=3,r=1e3,n=!0)=>{if(n){const s=w(e);if(s)return s}try{const s=await fetch(e,{headers:f()});if(s.status===403){const i=s.headers.get("x-ratelimit-remaining"),g=s.headers.get("x-ratelimit-reset");if(i==="0"){const p=new Date(parseInt(g)*1e3);throw new Error(`Rate limit exceeded. Resets at ${p.toLocaleTimeString()}`)}throw new Error("Forbidden: Check your access token")}if(s.status===404)throw new Error("Resource not found");if(!s.ok)throw new Error(`HTTP ${s.status}: ${s.statusText}`);const a={data:await s.json(),rateLimit:{remaining:parseInt(s.headers.get("x-ratelimit-remaining")||"0"),limit:parseInt(s.headers.get("x-ratelimit-limit")||"0"),reset:parseInt(s.headers.get("x-ratelimit-reset")||"0")}};return n&&y(e,a),a}catch(s){if(t>0&&!s.message.includes("Rate limit")){const a=Math.random()*100;return await R(r+a),o(e,t-1,r*2,n)}throw s}},T=async(e,t={})=>{const{language:r="",minStars:n=0,sort:s="stars",order:a="desc",page:i=1,perPage:g=30}=t;let p=e;r&&(p+=`+language:${encodeURIComponent(r)}`),n>0&&(p+=`+stars:>=${n}`);const u=`${d}/search/repositories?q=${encodeURIComponent(p)}&sort=${s}&order=${a}&page=${i}&per_page=${g}`;return o(u)},C=async(e={})=>{const{language:t="",page:r=1,perPage:n=30}=e,s=new Date;s.setDate(s.getDate()-h);let i=`created:>${s.toISOString().split("T")[0]}`;t&&(i+=`+language:${encodeURIComponent(t)}`);const g=`${d}/search/repositories?q=${encodeURIComponent(i)}&sort=stars&order=desc&page=${r}&per_page=${n}`;return o(g)},A=async(e,t)=>{const r=`${d}/repos/${e}/${t}`;return o(r)},E=async(e,t)=>{try{const r=`${d}/repos/${e}/${t}/readme`,n=await o(r);if(n.data.content){const s=atob(n.data.content);return{...n,data:{...n.data,decodedContent:s}}}return n}catch(r){if(r.message.includes("not found"))return{data:null,rateLimit:null};throw r}},S=async(e,t)=>{const r=`${d}/repos/${e}/${t}/languages`;return o(r)},_=async(e,t,r=10)=>{const n=`${d}/repos/${e}/${t}/events?per_page=${r}`;return o(n)};export{E as a,S as b,_ as c,C as d,A as g,T as s};
